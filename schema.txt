Draft schema (MongoDB style)
1) users

_id

email (unique)

passwordHash

firstName

lastName

mobile

country

createdAt

updatedAt

Optional

dob

sex

emergencyContact: { name, mobile, relationship }

tshirtSizeDefault

2) events

One document per event, even if it supports virtual, on-site, and hybrid.

_id

slug (unique, used in URL)

title

organiserName

description

status: "draft" | "published" | "closed"

eventTypesAllowed: ["virtual","onsite","hybrid"]

Dates

registrationOpenAt

registrationCloseAt

eventStartAt

eventEndAt

Location

venueName

venueAddress

city

province

country

geo: { lat, lng } (optional)

onsiteCheckinWindows: [{ startAt, endAt }]

Virtual rules

virtualWindow: { startAt, endAt }

proofTypesAllowed: ["gps","photo","manual"] (you can restrict per event)

Branding

bannerImageUrl

logoUrl

Audit

createdAt

updatedAt

3) event_categories (or distances)

If you prefer, embed this inside events. I recommend separate collection if you plan to reuse categories across events.

_id

eventId

name (example: "5K", "10K", "21K")

typeOptionsAllowed: ["virtual","onsite","hybrid"] (optional override)

fee: { currency: "PHP", amount: 799 }

slotsTotal (null if unlimited)

slotsRemaining (or compute from registrations)

inclusions: ["bib","medal","shirt"]

cutOffTimeMinutes (optional)

requiresTshirtSize: true/false

createdAt

updatedAt

4) registrations

This is your core. One per participant per event per category.

_id

eventId

categoryId

userId (nullable if you allow guest checkout)

Participant details (snapshot)

participant: {
firstName,
lastName,
email,
mobile,
country,
dob,
sex,
emergencyContact: { name, mobile, relationship }
}

Registration choice

participationMode: "virtual" | "onsite" | "hybrid"

tshirtSize

teamName (optional)

notes (optional)

Pricing snapshot

pricing: {
currency,
baseFee,
discountAmount,
totalFee,
promoCode
}

Status

status: "pending_payment" | "paid" | "confirmed" | "cancelled" | "refunded"

paymentStatus: "unpaid" | "paid" | "failed" | "refunded"

confirmationCode (unique human-friendly code)

bibNumber (optional, assigned later)

waveOrBatch (optional)

Timestamps

registeredAt

paidAt

confirmedAt

cancelledAt

Audit

createdAt

updatedAt

Indexes you’ll want

unique: (eventId, categoryId, participant.email) if you want “one entry per email”

or unique: (eventId, categoryId, userId) if account is required

index: eventId + status

index: confirmationCode

5) payments

Keep payments separate so you can support partial payments, retries, refunds, and multiple payment providers.

_id

registrationId

userId

provider: "paymongo" | "gcash" | "paypal" | "stripe" | "manual"

providerRef (payment intent id, charge id, etc.)

amount: { currency, value }

status: "created" | "processing" | "paid" | "failed" | "refunded"

paidAt

rawWebhook (optional, store minimal)

createdAt

updatedAt

6) run_submissions (virtual proof)

This is where “virtual” and the virtual part of “hybrid” gets validated.

_id

registrationId

eventId

userId

categoryId

Proof

proofType: "gps" | "photo" | "manual"

activity: {
distanceKm,
durationSeconds,
startAt,
endAt,
gpsFileUrl,
stravaActivityUrl,
screenshotUrl,
notes
}

Validation

status: "submitted" | "needs_review" | "approved" | "rejected"

reviewedBy

reviewedAt

reviewNotes

createdAt
updatedAt

Indexes

eventId + status

registrationId (unique if only one submission allowed)

7) onsite_checkins

For on-site and the on-site part of hybrid.

_id

registrationId

eventId

scannedAt

scannedBy (staff user id)

checkinMethod: "qr" | "manual"

station (optional)

notes (optional)